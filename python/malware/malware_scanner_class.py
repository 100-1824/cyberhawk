"""
MalwareScanner Class

Purpose: Scans files for malware and threats.

This class wraps the existing malware_scanner.py and malware_analyzer.py functionality
"""

import os
import requests
import hashlib
import subprocess
from pathlib import Path
from .malware_report import MalwareReport
from .quarantine import QuarantineFile


class MalwareScanner:
    """
    Scans files for malware using multiple detection methods:
    - VirusTotal API
    - MalwareBazaar API
    - Behavioral analysis
    - Static analysis
    """

    def __init__(self, api_keys=None):
        """
        Initialize MalwareScanner

        Args:
            api_keys: Dictionary of API keys (virustotal, malwarebazaar, etc.)
        """
        self.api_keys = api_keys or {}
        self.scan_results = {}

    def scanFile(self, filePath):
        """
        Scans a specific file.

        Performs comprehensive malware scanning including:
        - File hash calculation
        - VirusTotal lookup
        - MalwareBazaar lookup
        - Behavioral analysis
        - Static analysis

        Args:
            filePath: Path to file to scan

        Returns:
            MalwareReport: Scan results
        """
        if not os.path.exists(filePath):
            raise FileNotFoundError(f"File not found: {filePath}")

        # Calculate file hash
        file_hash = self._calculateFileHash(filePath)
        filename = os.path.basename(filePath)
        file_id = hashlib.md5(filename.encode()).hexdigest()[:8]

        # Create report
        report = MalwareReport(file_id, filename)
        report.file_hash = file_hash
        report.file_size = os.path.getsize(filePath)

        # Query VirusTotal
        if 'virustotal' in self.api_keys:
            vt_results = self.queryVirusTotal(file_hash)
            if vt_results:
                report.setVirusTotalResults(vt_results)

        # Query MalwareBazaar
        mb_results = self.queryMalwareBazaar(file_hash)
        if mb_results:
            report.scan_results['malwarebazaar'] = mb_results

        # Behavioral analysis
        behavioral_results = self.behavioralAnalysis(filePath)
        report.setBehavioralAnalysis(behavioral_results)

        # Assess threat level
        report.assessThreatLevel()

        # Save report
        report.saveToFile()

        # Auto-quarantine if threat is high or critical
        if report.threat_level in ['high', 'critical']:
            self.quarantineFile(filePath, report.threat_level)

        return report

    def queryVirusTotal(self, hash):
        """
        Checks file hash against VirusTotal.

        Args:
            hash: SHA256 hash of the file

        Returns:
            dict: VirusTotal API response or None
        """
        api_key = self.api_keys.get('virustotal')
        if not api_key:
            return None

        try:
            url = f"https://www.virustotal.com/api/v3/files/{hash}"
            headers = {"x-apikey": api_key}

            response = requests.get(url, headers=headers, timeout=10)

            if response.status_code == 200:
                return response.json()
            else:
                return None

        except Exception as e:
            print(f"VirusTotal query error: {str(e)}")
            return None

    def queryMalwareBazaar(self, hash):
        """
        Checks hash against MalwareBazaar.

        Args:
            hash: SHA256 hash of the file

        Returns:
            dict: MalwareBazaar API response or None
        """
        try:
            url = "https://mb-api.abuse.ch/api/v1/"
            data = {"query": "get_info", "hash": hash}

            response = requests.post(url, data=data, timeout=10)

            if response.status_code == 200:
                return response.json()
            else:
                return None

        except Exception as e:
            print(f"MalwareBazaar query error: {str(e)}")
            return None

    def behavioralAnalysis(self, file):
        """
        Performs behavioral analysis.

        Analyzes file behavior patterns, API calls, network connections,
        and other dynamic indicators.

        Args:
            file: Path to file for analysis

        Returns:
            dict: Behavioral analysis results
        """
        results = {
            'suspicious_behaviors': [],
            'file_operations': [],
            'network_activity': [],
            'registry_access': [],
            'process_creation': []
        }

        # Check file extension
        _, ext = os.path.splitext(file)
        suspicious_extensions = ['.exe', '.dll', '.scr', '.bat', '.vbs', '.ps1']
        if ext.lower() in suspicious_extensions:
            results['suspicious_behaviors'].append(f"Suspicious extension: {ext}")

        # Check file size
        file_size = os.path.getsize(file)
        if file_size < 1024:  # Very small executable
            results['suspicious_behaviors'].append("Unusually small file size")
        elif file_size > 100 * 1024 * 1024:  # Very large
            results['suspicious_behaviors'].append("Unusually large file size")

        # Additional behavioral checks could be added here
        # (requires running the file in a sandbox environment)

        return results

    def quarantineFile(self, filePath, threatType):
        """
        Quarantine a malicious file

        Args:
            filePath: Path to file to quarantine
            threatType: Type of threat detected

        Returns:
            dict: Quarantine operation result
        """
        filename = os.path.basename(filePath)
        quarantine_obj = QuarantineFile(filename, filePath, threatType)
        return quarantine_obj.quarantine()

    def _calculateFileHash(self, filePath, algorithm='sha256'):
        """
        Calculate file hash

        Args:
            filePath: Path to file
            algorithm: Hash algorithm (md5, sha1, sha256)

        Returns:
            str: File hash
        """
        hash_func = hashlib.new(algorithm)

        with open(filePath, 'rb') as f:
            while chunk := f.read(8192):
                hash_func.update(chunk)

        return hash_func.hexdigest()

    def scanDirectory(self, directory, recursive=True):
        """
        Scan all files in a directory

        Args:
            directory: Directory path
            recursive: Whether to scan subdirectories

        Returns:
            list: List of MalwareReport objects
        """
        reports = []
        path = Path(directory)

        if not path.exists() or not path.is_dir():
            return reports

        # Get files
        if recursive:
            files = path.rglob('*')
        else:
            files = path.glob('*')

        for file_path in files:
            if file_path.is_file():
                try:
                    report = self.scanFile(str(file_path))
                    reports.append(report)
                except Exception as e:
                    print(f"Error scanning {file_path}: {str(e)}")

        return reports

    def getApiKeys(self):
        """Get configured API keys"""
        return {k: '***' + v[-4:] if v else None for k, v in self.api_keys.items()}

    def setApiKey(self, service, key):
        """
        Set API key for a service

        Args:
            service: Service name (virustotal, malwarebazaar, etc.)
            key: API key
        """
        self.api_keys[service] = key
