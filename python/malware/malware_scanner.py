#!/usr/bin/env python3
"""
CyberHawk Malware Scanner - Multi-API Edition
Uses multiple free malware detection services for accurate detection
"""

import os
import sys
import json
import hashlib
import math
import time
import argparse
import requests
import subprocess
from pathlib import Path
from datetime import datetime
from dotenv import load_dotenv

# Load environment variables from .env file
# Get the project root directory (two levels up from this script)
project_root = Path(__file__).parent.parent.parent
env_path = project_root / '.env'

# Load .env file if it exists, otherwise fall back to .env.example
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
else:
    env_example_path = project_root / '.env.example'
    if env_example_path.exists():
        load_dotenv(dotenv_path=env_example_path)
    else:
        print("[WARNING] No .env or .env.example file found. Using default configuration.")

# Configuration - now loaded from environment variables
CONFIG = {
    'DATA_DIR': os.getenv('UPLOAD_DIR', 'assets/data').rstrip('/'),
    'UPLOADS_DIR': os.getenv('UPLOAD_DIR', 'assets/data/malware_uploads').rstrip('/'),
    'VIRUSTOTAL_API_KEY': os.getenv('VIRUSTOTAL_API_KEY'),
    'USE_ML_MODEL': os.getenv('USE_ML_MODEL', 'false').lower() == 'true',
    'MIN_ENGINES_FOR_DETECTION': int(os.getenv('MIN_ENGINES_FOR_DETECTION', '3')),
    'HYBRID_API_KEY': os.getenv('HYBRID_API_KEY'),
}

class StaticAnalyzer:
    """Perform static analysis without ML"""
    
    @staticmethod
    def calculate_entropy(data):
        """Calculate Shannon entropy"""
        if not data or len(data) == 0:
            return 0
        
        byte_counts = [0] * 256
        for byte in data[:8192]:  # Sample first 8KB
            byte_counts[byte] += 1
        
        entropy = 0
        data_len = min(len(data), 8192)
        for count in byte_counts:
            if count > 0:
                p_x = count / data_len
                entropy += -p_x * math.log2(p_x)
        
        return entropy
    
    @staticmethod
    def detect_packer(data):
        """Detect common packers"""
        packers = {
            b'UPX': 'UPX',
            b'PECompact': 'PECompact',
            b'ASPack': 'ASPack',
            b'Themida': 'Themida',
            b'VMProtect': 'VMProtect',
            b'MPRESS': 'MPRESS',
            b'NSPack': 'NSPack',
            b'PELock': 'PELock'
        }
        
        detected = []
        for signature, name in packers.items():
            if signature in data[:4096]:
                detected.append(name)
        
        return detected
    
    @staticmethod
    def extract_suspicious_strings(data, max_strings=100):
        """Extract suspicious strings from binary"""
        suspicious_patterns = {
            'Network': [b'http://', b'https://', b'ftp://', b'tcp://', b'udp://'],
            'Commands': [b'cmd.exe', b'powershell', b'wscript', b'cscript', b'rundll32'],
            'Registry': [b'HKEY_', b'RegSetValue', b'RegCreateKey', b'RegDeleteKey'],
            'Crypto': [b'bitcoin', b'wallet', b'ransom', b'.encrypted', b'decrypt'],
            'Suspicious': [b'password', b'passwd', b'admin', b'root', b'backdoor'],
            'APIs': [b'CreateRemoteThread', b'VirtualAlloc', b'WriteProcessMemory']
        }
        
        found_strings = []
        strings = []
        current_string = []
        
        # Extract printable strings
        for byte in data[:65536]:  # Analyze first 64KB
            if 32 <= byte <= 126:
                current_string.append(chr(byte))
            else:
                if len(current_string) >= 4:
                    string = ''.join(current_string)
                    if len(string) <= 100:
                        strings.append(string)
                current_string = []
        
        # Check for suspicious patterns
        data_sample = data[:65536]
        for category, patterns in suspicious_patterns.items():
            for pattern in patterns:
                if pattern in data_sample:
                    found_strings.append({
                        'category': category,
                        'string': pattern.decode('utf-8', errors='ignore'),
                        'suspicious': True
                    })
        
        return found_strings[:max_strings]

class MalwareScanner:
    def __init__(self):
        self.progress_file = os.path.join(CONFIG['DATA_DIR'], 'malware_scan_progress.json')
        self.reports_file = os.path.join(CONFIG['DATA_DIR'], 'malware_reports.json')
        self.stats_file = os.path.join(CONFIG['DATA_DIR'], 'malware_stats.json')
        
        # Ensure directories exist
        os.makedirs(CONFIG['DATA_DIR'], exist_ok=True)
        os.makedirs(CONFIG['UPLOADS_DIR'], exist_ok=True)
    
    def update_progress(self, file_id, progress, status, stage):
        """Update scan progress"""
        try:
            data = {
                'file_id': file_id,
                'progress': progress,
                'status': status,
                'stage': stage,
                'updated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            with open(self.progress_file, 'w') as f:
                json.dump(data, f, indent=2)
                
        except Exception as e:
            print(f"[ERROR] Failed to update progress: {e}")
    
    def calculate_hashes(self, filepath):
        """Calculate multiple file hashes"""
        try:
            md5_hash = hashlib.md5()
            sha1_hash = hashlib.sha1()
            sha256_hash = hashlib.sha256()
            
            with open(filepath, 'rb') as f:
                while chunk := f.read(8192):
                    md5_hash.update(chunk)
                    sha1_hash.update(chunk)
                    sha256_hash.update(chunk)
            
            return {
                'md5': md5_hash.hexdigest(),
                'sha1': sha1_hash.hexdigest(),
                'sha256': sha256_hash.hexdigest()
            }
        except Exception as e:
            print(f"[ERROR] Hash calculation failed: {e}")
            return {'md5': None, 'sha1': None, 'sha256': None}
    
    def check_virustotal(self, file_hash):
        """Check file on VirusTotal using v3 API"""
        if not CONFIG['VIRUSTOTAL_API_KEY']:
            return None
        
        try:
            url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
            headers = {"x-apikey": CONFIG['VIRUSTOTAL_API_KEY']}
            
            response = requests.get(url, headers=headers, timeout=15)
            
            if response.status_code == 200:
                data = response.json()
                attrs = data.get('data', {}).get('attributes', {})
                stats = attrs.get('last_analysis_stats', {})
                results = attrs.get('last_analysis_results', {})
                
                # Get detection details
                detected_by = []
                for engine, result in results.items():
                    if result.get('category') in ['malicious', 'suspicious']:
                        detected_by.append({
                            'engine': engine,
                            'result': result.get('result', 'Unknown')
                        })
                
                return {
                    'malicious': stats.get('malicious', 0),
                    'suspicious': stats.get('suspicious', 0),
                    'harmless': stats.get('harmless', 0),
                    'undetected': stats.get('undetected', 0),
                    'total_engines': sum(stats.values()),
                    'detected_by': detected_by[:10],  # Top 10 detections
                    'scan_date': attrs.get('last_analysis_date', 'Unknown')
                }
            elif response.status_code == 404:
                # File not in database - could submit it
                return {
                    'malicious': 0,
                    'suspicious': 0,
                    'harmless': 0,
                    'undetected': 0,
                    'total_engines': 0,
                    'detected_by': [],
                    'not_found': True
                }
            else:
                print(f"[VT] API returned status {response.status_code}")
                return None
                
        except requests.exceptions.RequestException as e:
            print(f"[VT] Request error: {e}")
            return None
        except Exception as e:
            print(f"[VT] Error: {e}")
            return None
    
    def check_malwarebazaar(self, file_hash):
        """Check MalwareBazaar database (abuse.ch)"""
        try:
            url = "https://mb-api.abuse.ch/api/v1/"
            data = {
                'query': 'get_info',
                'hash': file_hash
            }
            
            response = requests.post(url, data=data, timeout=10)
            
            if response.status_code == 200:
                result = response.json()
                if result.get('query_status') == 'hash_found':
                    data = result.get('data', [{}])[0]
                    return {
                        'found': True,
                        'malware_family': data.get('signature', 'Unknown'),
                        'tags': data.get('tags', []),
                        'first_seen': data.get('first_seen', 'Unknown'),
                        'threat_level': 'MALICIOUS'
                    }
            
            return {'found': False}
            
        except Exception as e:
            print(f"[MalwareBazaar] Error: {e}")
            return None
    
    def check_threatfox(self, file_hash):
        """Check ThreatFox IOC database"""
        try:
            url = "https://threatfox-api.abuse.ch/api/v1/"
            data = {
                'query': 'search_hash',
                'hash': file_hash
            }
            
            response = requests.post(url, json=data, timeout=10)
            
            if response.status_code == 200:
                result = response.json()
                if result.get('query_status') == 'ok' and result.get('data'):
                    ioc = result['data'][0]
                    return {
                        'found': True,
                        'malware': ioc.get('malware', 'Unknown'),
                        'threat_type': ioc.get('threat_type', 'Unknown'),
                        'confidence': ioc.get('confidence_level', 0)
                    }
            
            return {'found': False}
            
        except Exception as e:
            print(f"[ThreatFox] Error: {e}")
            return None
    
    def scan_with_windows_defender(self, filepath):
        """Use Windows Defender if available (Windows only)"""
        try:
            # Check if running on Windows
            if sys.platform != 'win32':
                return None
            
            # Use Windows Defender command line
            cmd = f'powershell -Command "Start-Process -FilePath \'C:\\Program Files\\Windows Defender\\MpCmdRun.exe\' -ArgumentList \'-Scan\', \'-ScanType 3\', \'-File\', \'{filepath}\' -Wait -NoNewWindow"'
            
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            
            # Check if threat was found
            if 'found' in result.stdout.lower() or 'threat' in result.stdout.lower():
                return {'detected': True, 'engine': 'Windows Defender'}
            
            return {'detected': False, 'engine': 'Windows Defender'}
            
        except Exception as e:
            print(f"[Defender] Error: {e}")
            return None
    
    def analyze_yara_rules(self, filepath):
        """Simple YARA-like pattern matching"""
        patterns = {
            'ransomware': [
                b'Your files have been encrypted',
                b'Bitcoin wallet',
                b'pay the ransom',
                b'.encrypted',
                b'DECRYPT-FILES.txt'
            ],
            'trojan': [
                b'CreateRemoteThread',
                b'VirtualAllocEx',
                b'WriteProcessMemory',
                b'SetWindowsHookEx'
            ],
            'backdoor': [
                b'bind shell',
                b'reverse shell',
                b'nc.exe',
                b'netcat',
                b'4444'  # Common backdoor port
            ],
            'keylogger': [
                b'GetAsyncKeyState',
                b'GetKeyState',
                b'SetWindowsHookEx',
                b'keylog'
            ]
        }
        
        detected = []
        try:
            with open(filepath, 'rb') as f:
                data = f.read(65536)  # Read first 64KB
                
                for category, sigs in patterns.items():
                    for sig in sigs:
                        if sig in data:
                            detected.append(category)
                            break
        except:
            pass
        
        return detected
    
    def calculate_threat_score(self, vt_result, mb_result, tf_result, yara_patterns, static_analysis):
        """Calculate overall threat score from multiple sources"""
        score = 0
        max_score = 100
        detection_sources = []
        
        # VirusTotal score (40 points max)
        if vt_result:
            if vt_result.get('malicious', 0) > 0:
                vt_score = min(40, vt_result['malicious'] * 2)
                score += vt_score
                detection_sources.append(f"VirusTotal ({vt_result['malicious']} engines)")
            elif vt_result.get('suspicious', 0) > 0:
                score += min(20, vt_result['suspicious'] * 2)
                detection_sources.append(f"VirusTotal (suspicious)")
        
        # MalwareBazaar (20 points)
        if mb_result and mb_result.get('found'):
            score += 20
            detection_sources.append(f"MalwareBazaar ({mb_result.get('malware_family', 'Unknown')})")
        
        # ThreatFox (15 points)
        if tf_result and tf_result.get('found'):
            score += 15
            detection_sources.append(f"ThreatFox ({tf_result.get('malware', 'Unknown')})")
        
        # YARA patterns (15 points)
        if yara_patterns:
            score += min(15, len(yara_patterns) * 5)
            detection_sources.append(f"Pattern matching ({', '.join(yara_patterns)})")
        
        # Static analysis (10 points)
        if static_analysis:
            if static_analysis.get('entropy', 0) > 7.5:
                score += 5
            if static_analysis.get('packers'):
                score += 5
                detection_sources.append(f"Packed ({', '.join(static_analysis['packers'])})")
        
        # Determine threat level
        if score >= 60:
            threat_level = 'MALICIOUS'
        elif score >= 30:
            threat_level = 'SUSPICIOUS'
        elif score >= 10:
            threat_level = 'LOW'
        else:
            threat_level = 'CLEAN'
        
        return {
            'score': min(score, max_score),
            'threat_level': threat_level,
            'detection_sources': detection_sources
        }
    
    def scan_file(self, file_id, filepath):
        """Comprehensive file scan using multiple sources"""
        print(f"\n[SCAN] Starting multi-source scan: {filepath}")
        
        filename = os.path.basename(filepath)
        file_size = os.path.getsize(filepath)
        file_type = Path(filepath).suffix.lower()
        
        # Stage 1: Static Analysis (25%)
        self.update_progress(file_id, 10, 'Calculating hashes...', 'static')
        hashes = self.calculate_hashes(filepath)
        
        self.update_progress(file_id, 15, 'Analyzing file structure...', 'static')
        
        # Read file for analysis
        with open(filepath, 'rb') as f:
            file_data = f.read(min(file_size, 1024 * 1024))  # Max 1MB
        
        # Static analysis
        entropy = StaticAnalyzer.calculate_entropy(file_data)
        packers = StaticAnalyzer.detect_packer(file_data)
        suspicious_strings = StaticAnalyzer.extract_suspicious_strings(file_data)
        
        static_analysis = {
            'entropy': entropy,
            'packers': packers,
            'suspicious_strings': suspicious_strings
        }
        
        self.update_progress(file_id, 25, 'Static analysis complete', 'static')
        
        # Stage 2: Multi-source Detection (50%)
        self.update_progress(file_id, 30, 'Checking VirusTotal...', 'ml')
        vt_result = self.check_virustotal(hashes['sha256'])
        time.sleep(0.5)  # Rate limiting
        
        self.update_progress(file_id, 40, 'Checking MalwareBazaar...', 'ml')
        mb_result = self.check_malwarebazaar(hashes['md5'])
        
        self.update_progress(file_id, 45, 'Checking ThreatFox...', 'ml')
        tf_result = self.check_threatfox(hashes['sha256'])
        
        self.update_progress(file_id, 50, 'Detection analysis complete', 'ml')
        
        # Stage 3: Behavioral Analysis (75%)
        self.update_progress(file_id, 60, 'Analyzing behavior patterns...', 'behavioral')
        yara_patterns = self.analyze_yara_rules(filepath)
        
        self.update_progress(file_id, 70, 'Checking Windows Defender...', 'behavioral')
        defender_result = self.scan_with_windows_defender(filepath) if sys.platform == 'win32' else None
        
        self.update_progress(file_id, 75, 'Behavioral analysis complete', 'behavioral')
        
        # Stage 4: Generate Report (100%)
        self.update_progress(file_id, 85, 'Calculating threat score...', 'report')
        
        # Calculate threat score
        threat_assessment = self.calculate_threat_score(
            vt_result, mb_result, tf_result, yara_patterns, static_analysis
        )
        
        # Build behaviors list
        behaviors = []
        
        if entropy > 7.5:
            behaviors.append({
                'type': 'High Entropy',
                'severity': 'high',
                'description': f'File entropy {entropy:.2f} indicates possible encryption/packing'
            })
        
        if packers:
            behaviors.append({
                'type': 'Packer Detected',
                'severity': 'high',
                'description': f'Detected packer: {", ".join(packers)}'
            })
        
        if yara_patterns:
            behaviors.append({
                'type': 'Malware Patterns',
                'severity': 'high',
                'description': f'Detected patterns: {", ".join(yara_patterns)}'
            })
        
        if len(suspicious_strings) > 5:
            behaviors.append({
                'type': 'Suspicious Strings',
                'severity': 'medium',
                'description': f'Found {len(suspicious_strings)} suspicious strings'
            })
        
        # Create detailed report
        report = {
            'file_id': file_id,
            'filename': filename,
            'file_path': filepath,
            'file_size': file_size,
            'file_type': file_type,
            'scan_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'md5': hashes['md5'],
            'sha1': hashes['sha1'],
            'sha256': hashes['sha256'],
            'threat_level': threat_assessment['threat_level'],
            'threat_score': threat_assessment['score'],
            'detection_sources': ', '.join(threat_assessment['detection_sources']) if threat_assessment['detection_sources'] else 'None',
            'ml_confidence': 0,  # ML model disabled
            'malware_probability': threat_assessment['score'],
            'vt_detections': vt_result['malicious'] if vt_result else 0,
            'vt_suspicious': vt_result['suspicious'] if vt_result else 0,
            'vt_total_engines': vt_result['total_engines'] if vt_result else 0,
            'vt_detected_by': vt_result.get('detected_by', []) if vt_result else [],
            'malwarebazaar': mb_result if mb_result else {'found': False},
            'threatfox': tf_result if tf_result else {'found': False},
            'yara_patterns': yara_patterns,
            'entropy': entropy,
            'is_packed': len(packers) > 0,
            'packers': packers,
            'suspicious_apis': 0,  # Would need PE parsing
            'behaviors': behaviors,
            'strings': [s['string'] for s in suspicious_strings[:20]]  # Top 20 strings
        }
        
        # Save report
        self.save_report(report)
        
        # Update statistics
        self.update_statistics(threat_assessment['threat_level'])
        
        # Update queue status
        self.update_queue_status(file_id, 'complete')
        
        self.update_progress(file_id, 100, 'Scan complete', 'report')
        
        print(f"[COMPLETE] Scan finished: {threat_assessment['threat_level']} (Score: {threat_assessment['score']}/100)")
        
        return report
    
    def save_report(self, report):
        """Save analysis report"""
        try:
            reports = []
            if os.path.exists(self.reports_file):
                with open(self.reports_file, 'r') as f:
                    content = f.read()
                    if content:
                        reports = json.loads(content)
            
            # Remove old report for same file
            reports = [r for r in reports if r.get('file_id') != report['file_id']]
            
            # Add new report
            reports.insert(0, report)
            reports = reports[:100]  # Keep last 100
            
            with open(self.reports_file, 'w') as f:
                json.dump(reports, f, indent=2)
                
        except Exception as e:
            print(f"[ERROR] Failed to save report: {e}")
    
    def update_statistics(self, threat_level):
        """Update scan statistics"""
        try:
            stats = {
                'total_scans': 0,
                'malware_detected': 0,
                'clean_files': 0,
                'suspicious_files': 0,
                'last_scan': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            if os.path.exists(self.stats_file):
                with open(self.stats_file, 'r') as f:
                    content = f.read()
                    if content:
                        stats = json.loads(content)
            
            stats['total_scans'] = stats.get('total_scans', 0) + 1
            
            if threat_level == 'MALICIOUS':
                stats['malware_detected'] = stats.get('malware_detected', 0) + 1
            elif threat_level in ['SUSPICIOUS', 'LOW']:
                stats['suspicious_files'] = stats.get('suspicious_files', 0) + 1
            else:
                stats['clean_files'] = stats.get('clean_files', 0) + 1
            
            stats['last_scan'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            with open(self.stats_file, 'w') as f:
                json.dump(stats, f, indent=2)
                
        except Exception as e:
            print(f"[ERROR] Failed to update stats: {e}")
    
    def update_queue_status(self, file_id, status):
        """Update scan queue status"""
        try:
            queue_file = os.path.join(CONFIG['DATA_DIR'], 'scan_queue.json')
            if os.path.exists(queue_file):
                with open(queue_file, 'r') as f:
                    content = f.read()
                    if content:
                        queue = json.loads(content)
                    else:
                        queue = []
                
                for item in queue:
                    if item.get('id') == file_id:
                        item['status'] = status
                        break
                
                with open(queue_file, 'w') as f:
                    json.dump(queue, f, indent=2)
                    
        except Exception as e:
            print(f"[ERROR] Failed to update queue: {e}")

def main():
    parser = argparse.ArgumentParser(description='CyberHawk Malware Scanner')
    parser.add_argument('--file-id', required=True, help='File ID to scan')
    args = parser.parse_args()
    
    scanner = MalwareScanner()
    
    print("=" * 70)
    print("CYBERHAWK MALWARE SCANNER - MULTI-SOURCE EDITION")
    print("=" * 70)
    print("Detection Sources:")
    print("  ✓ VirusTotal API")
    print("  ✓ MalwareBazaar (abuse.ch)")
    print("  ✓ ThreatFox IOC Database")
    print("  ✓ Pattern Matching (YARA-like)")
    print("  ✓ Static Analysis")
    if sys.platform == 'win32':
        print("  ✓ Windows Defender")
    print("=" * 70)
    
    # Find file in uploads directory
    file_id = args.file_id
    uploads_dir = CONFIG['UPLOADS_DIR']
    
    if not os.path.exists(uploads_dir):
        print(f"[ERROR] Uploads directory not found: {uploads_dir}")
        sys.exit(1)
    
    target_file = None
    for filename in os.listdir(uploads_dir):
        if filename.startswith(file_id + '_'):
            target_file = os.path.join(uploads_dir, filename)
            break
    
    if not target_file or not os.path.exists(target_file):
        print(f"[ERROR] File not found for ID: {file_id}")
        sys.exit(1)
    
    # Scan file
    report = scanner.scan_file(file_id, target_file)
    
    print("\n" + "=" * 70)
    print("SCAN RESULTS")
    print("=" * 70)
    print(f"Threat Level: {report['threat_level']}")
    print(f"Threat Score: {report['threat_score']}/100")
    print(f"VirusTotal: {report['vt_detections']}/{report['vt_total_engines']} engines detected")
    if report['detection_sources'] != 'None':
        print(f"Detection Sources: {report['detection_sources']}")
    print("=" * 70)

if __name__ == '__main__':
    main()